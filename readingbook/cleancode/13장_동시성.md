# 13장_동시성

1. 동시성 프로그래밍이란
2. 동시성 프로그래밍이 필요한 이유
3. 안전한 동시성 프로그래밍 규칙
4. 동시성 테스트 방법
5. 오픈 소스 속 동시성 처리

---

## 동시성 프로그래밍이란?

- 애플리케이션을 효율적으로 실행하기 위해 멀티 코어를 활용하도록 구현하는 방식
    - 외부 서비스의 응답을 기다리면서 아무 일도 하지 않으면 CPU 사이클이 낭비된다.

*동시성이 구현되지 않은 경우,*

- 서버가 클라이언트의 요청이 완료되도록 기다리면, 다른 작업이 실행되지 못한다.
    - 서버(코어)를 늘려 처리량을 높인다. (병렬성 구현)
    - 서버 수가 늘어났지만, 요청을 처리할 때 까지 기다리기 때문에 다른 작업이 수행되지 못한다.
    

*동시성을 구현,*

- 서버가 클라이언트의 요청이 완료될 때 까지 기다리지 않고, 기다릴 동안 다른 작업도 수행한다.
    - 동시성을 구현한다고 클라이언트의 요청이 빨리 처리되는 것은 아니지만, 애플리케이션은 효율적으로 코어를 사용해 처리량을 높일 수 있다.

- 동시성은 클라이언트가 아닌 어플리케이션 관점에서 봐야 한다.
    - 어플리케이션이 동작하는 머신의 환경이 효율적으로 돌아가도록 메모리 누수나 자원이 낭비되지 않도록 신경 쓴다.

## 동시성 프로그래밍이 필요한 이유?

[***오해  1*** ] 

- 동시성은 항상 성능을 높여 주진 않고, `때때로` 성능을 높여준다.
- 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 많은 경우에만 성능이 높아진다.
    
    ex) 웹 브라우저에서 여러 가지 이미지 리소스들을 불러와 다운로드 할 때
    
    ex) JSP Servlet

  <p align="center">
   <img src="https://user-images.githubusercontent.com/80144039/174733679-ed014149-6ea3-458b-8f7b-60bd816f5074.png"/>
  </p>
  
  
    - 유저의 요청 마다 쓰레드를 쓰레드 풀에서 가져와 처리 한다.

[***오해  2***]

- 동시성을 구현하면 `설계를 바꿔야 한다`!
    - 단일 스레드 시스템과, 다중 스레드 시스템은 설계가 판이 하게 다르다.
    - ‘무엇’ 과 ‘언제’ 를 분리하면 시스템의 구조가 크게 달라진다.

 

[***오해  3***]

- 컨테이너를 사용해도 ‘동시성을 이해해야 한다’
    - 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다.
    - 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야 한다.

## 안전한 동시성 프로그래밍 규칙

1. 단일 책임 원칙 SRP 설계 - 동시성 관련 코드는 다른 코드와 분리해라
2. 공유 자료를 최대한 줄여라
    - 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 임계 영역을 ***synchronized*** 키워드로 보호해라 → 쓰레드 하나만 접근할 수 있다.
    - 임계 영역의 수를 최소화 해야 한다.

    </br>
    
    > 임계 영역(Critical Section)
    > 
    - 동일한 자원을 동시에 접근하는 작업
    - 공유 하는 변수 사용, 동일 파일 사용 등 실행하는 코드 영역

3. 자료 사본을 사용하라
    - 공유 자료를 줄이라면, 최대한 공유하지 않는 방법이 제일 좋다

4. Thread는 가능한 독립적으로 구현한다.
    - 다른 스레드와 자료를 공유하지 않는다.
    - 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다.
    - 모든 정보는 비공유 출처 (clinet의 request)에서 가져오며 로컬 변수에 저장한다.
    - 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.

5. 라이브러리를 이해하라
    - java.util.concurrent 패키지를 익혀라
    - Thread Safe한 컬렉션을 사용한다.
        - ConcurrentHashMap, AtomicLong
    - 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
    - 가능하다면 Thread가 Blocking 되지 않는 방법을 사용한다.
    
6. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라.
    - 공유 객체 하나에는 메서드 하나만 사용하라

</br>

    
  
***문제 상황***
      <p align="center">
       <img src="https://user-images.githubusercontent.com/80144039/174733948-488ea0bb-0068-44f2-b7c5-e7be3746df11.png"/>
     </p>
  
    
***해결 방안***
      <p align="center">
       <img src="https://user-images.githubusercontent.com/80144039/174734044-7772b557-f7f2-413d-a946-d42173fa43cf.png"/>
     </p>
  
   
    - 단점 Iterator을 사용 할 때마다 동시성 처리를 해줘야한다.
    
 ***Server Based Lock***
     <p align="center">
       <img src="https://user-images.githubusercontent.com/80144039/174734271-c86eb11b-7573-4d52-8c5e-35b50971b813.png"/>
     </p>
  
 ***Adapter Based Lock***
     <p align="center">
       <img src="https://user-images.githubusercontent.com/80144039/174734366-bf0321ba-3c7f-4b60-8626-38f714212ec0.png"/>
     </p>
     
    
   
   ## 동시성 코드를 테스트 해야 한다.
    
    - 문제를 노출하는 테스트 케이스를 작성, 실패 시 원인을 추적하라.
    - 코드의 보조 코드를 넣어 돌려라
        - 드물게 발생하는 오류를 자주 발생시키도록 보조 코드를 추가한다
    - 실제 환경이나 테스트 환경에서 돌려본다.
    
   ## 오픈 소스 속 동시성 처리
    
    - AtomicLong
        - Long 자료형을 thread safe하게 랩핑한 값
        - CPU 레벨의 연산인 CAS(compare-and-swap)을 지원해서 thread safe하게 값을 사용할 수 있다.
    - ReentrantReadWriteLock
        - 동시에 읽는 스레드는 허용하지만 읽기 & 쓰기, 쓰기 & 쓰기는 차단
