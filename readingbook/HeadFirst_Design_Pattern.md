## **SimUDuck -**  상속은 모든 해결책이 아니다!


<p align="center">
![image](https://user-images.githubusercontent.com/80144039/152934624-af3d0f5b-c9a2-4bfb-96e4-4f0fea800109.png)
</p>

- 오리가 날 수 있게  fly()함수를 수퍼 클래스에 생성했다.
- 모든 서브 클래스들이 fly()를 상속 받게 되었다.

    ‼ 날 수 없는 오리들도 fly()를 상속 받았다‼
    

🤔 **fly()를 서브클래스에서 오버라이드하면 해결 되지 않나요?**

 → 제품이 계속해서 변경 된다면, 매번 서브 클래스의 fly() 함수를 확인해가면서 변경해야 한다.

---

## **변화에 유연하려면? - 디자인 원칙을 적용해봅시다.**

### 디자인 원칙 1 : 바뀌는 부분과 그렇지 않은 부분 분리하기

코드에 새로운 요구 사항이 있을 때 마다 바뀌는 부분이 있으면, 그 행동을 분리해야 한다.

<aside>
  
💡 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않게 '캡슐화'  하면, 코드를 변경하는 과정에서 시스템의 유연성을 향상 시킬 수 있다.
  
</aside>

<p align="center">
![image](https://user-images.githubusercontent.com/80144039/152936286-31cd49f3-6f0e-4682-9050-f641562c9d01.png)
</p>


- Duck 클래스에서 변하는 부분은 quack(), fly()의 행위들로 분리해낸다.
